# Headline

// docsify serve docs
https://giantaxewhy.github.io/docs/

https://github.com/GiantAxeWhy/MVVM-why.git

http://81.70.248.176:12306/

      > An awesome project.
      > 在京东的半年工作中，负责四个项目的搭建，业务模块的实现联调等工作，主要技术栈使用的 vue。半年过程中提交了两片专利，一篇已经过审，一篇审查中，分别是 基于大数据的虚拟列表的不定高实现，
      与基于大数据的高性能深拷贝在项目中的应用。
      同时业余时间实现了自己的技术博客搭建采用 vue+express+mysql 的技术栈，同时前段时间自己实现了一个 min-vue,基本自主实现了一些核心基础功能.
      Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统。
      > 在虚拟滚动实现的过程中，封装了一个小组件
      > 1、计算当前可视区域的起始数据索引（startIndex）
      > 2、计算当前可视区域的末尾数据索引（endIndex）
      > 3、可视区域的数据，渲染到可视区域
      > 4、计算起始数据索引 在整个列表数据索引中的偏移位置（startOffset）并且设置到列表中 因此整个可视区域的渲染结构如下
      > 1）假定可视区域高度固定，称之为 screenHeight
      > 2）假定列表每项高度固定，称之为 itemSize
      > 3）假定列表数据称之为 listData
      > 4）假定当前滚动位置称之为 scrollTop
      > 由此可得出计算关系 1、列表总高度 listHeight = listData.length \* itemSize
      > 2、可显示的列表项数 visibleCount = Math.ceil(screenHeight / itemSize)
      > 3、数据的起始索引 startIndex = Math.floor(scrollTop / itemSize)
      > 4、数据的结束索引 endIndex = startIndex + visibleCount
      > 5、列表显示数据为 visibleData = listData.slice(startIndex,endIndex)
      > 当滚动后，由于渲染区域相对于可视区域已经发生了偏移，此时我需要获取一个偏移量 startOffset，通过样式控制将渲染区域偏移至可视区域中。
       偏移量 startOffset = scrollTop - (scrollTop % itemSize);
      > 扩展 当需要渲染的 item 高度不固定时
      以预估高度先行渲染，然后获取真实高度并缓存。

      定义组件属性 estimatedItemSize,用于接收预估高度
      并在初始时根据 estimatedItemSize 对 positions 进行初始化。

      由于列表项高度不定，并且我们维护了 positions，用于记录每一项的位置，而列表高度实际就等于列表中最后一项的底部距离列表顶部的位置。
      由于需要在渲染完成后，获取列表每项的位置信息并缓存，所以使用钩子函数 updated 来实现：
      滚动后获取列表开始索引的方法修改为通过缓存获取：

数组：连续
连续空间存储是数组的特点，下图是数组在内存中的存储示意图。

固定长度

因为数组的空间是连续的，这就意味着在内存中会有一整块空间来存放数组，如果不是固定长度，那么内存中位于数组之后的区域会没办法分配，内存不知道数组还要不要继续存放，要使用多长的空间。长度固定，就界定了数组使用内存的界限，数组之外的空间可以分配给别人使用。

相同数据类型
因为数组的长度是固定的，如果不是相同数据类型，一会存一个 int ，一会存一个 String ，两种不同长度的数据类型，不能保证各自存放几个，这样有悖固定长度的规定，所以也要是相同的数据类型。

我们看到 JSArray 是继承自 JSObject，也就是说，数组是一个特殊的对象。

那这就好解释为什么 JS 的数组可以存放不同的数据类型，它是个对象嘛，内部也是 key-value 的存储形式。

可以看到，底层就是个 Map ，key 为 0，1，2，3 这种索引，value 就是数组的元素。

数组的 index 其实是字符串。

# fast ：

快速的后备存储结构是 FixedArray ，并且数组长度 <= elements.length();

快数组是一种线性的存储方式。新创建的空数组，默认的存储方式是快数组，快数组长度是可变的，可以根据元素的增加和删除来动态调整存储空间大小，内部是通过扩容和收缩机制实现，那来看下源码中是怎么扩容和收缩的。
FixedArray 是 V8 实现的一个类似于数组的类，它表示一段固定长度的连续的内存。
也就是，扩容后的新容量 = 旧容量的 1.5 倍 + 16

扩容后会将数组拷贝到新的内存空间中
收缩：
可以看出收缩数组的判断是： 如果容量 >= length 的 2 倍 + 16，则进行收缩容量调整，否则用 holes 对象（什么事 holes 对象？下面来解释）填充未被初始化的位置。

# slow ：

慢数组是一种哈希表的内存形式。不用开辟大块连续的存储空间，节省了内存，但是由于需要维护这样一个 HashTable，其效率会比快数组低。

缓慢的后备存储结构是一个以数字为键的 HashTable 。

HashTable，维基百科中解释的很好：

散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

源码注释中的 fast 和 slow，只是简单的解释了一下，对应的是快数组和慢数组，下面来具体的看一下两种形式是如何实现的。

# 快转慢

也就是说，当对数组赋值时使用远超当前数组的容量+ 1024 时（这样出现了大于等于 1024 个空洞，这时候要对数组分配大量空间则将可能造成存储空间的浪费，为了空间的优化，会转化为慢数组。
代码实锤：
let a = [1, 2]
a[1030] = 1;
复制代码数组中只有三个元素，但是却在 1030 的位置存放了一个值，那么中间会有多于 1024 个空洞，这时就会变为慢数组。

# 慢转快

慢 -> 快
处于哈希表实现的数组，在每次空间增长时， V8 的启发式算法会检查其空间占用量， 若其空洞元素减少到一定程度，则会将其转化为快数组模式。

# 优略

快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。

# 高性能深拷贝

那么是否可以有一种实现的做法，只有当属性修改以后才对这部分数据做深拷贝，又能解决 JSON.parse(JSON.stringify(a)) 的局限呢。这种做法当然是存在的，唯一的点是我们如何知道用户修改了什么属性？
答案是 Proxy，通过拦截 set 和 get 就能达到我们想要的，当然 Object.defineProperty() 也可以。其实 Immer 这个库就是用了这种做法来生成不可变对象的，接下来就让我们来试着通过 Proxy 来实现高性能版的深拷贝。
